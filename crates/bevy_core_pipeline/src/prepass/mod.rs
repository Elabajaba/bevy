//! Run a prepass before the main pass to get the depth and/or normals texture.
//! The depth prepass texture is then used by the main pass to reduce overdraw.
//!
//! To enable the prepass, you need to add a `PrepassSettings` component to a `Camera`.
//! Both textures are available on the `PrepassTextures` component attached to each `Camera` with a `PrepassSettings`
//!
//! Currently only works for 3d

pub mod node;

use bevy_ecs::prelude::*;
use bevy_render::{
    render_phase::{CachedRenderPipelinePhaseItem, DrawFunctionId, EntityPhaseItem, PhaseItem},
    render_resource::{CachedRenderPipelineId, Extent3d},
    texture::CachedTexture,
};
use bevy_utils::FloatOrd;

/// Add a [`PrepassSettings`] component to a [`crate::prelude::Camera3d`] to perform a depth and/or normal prepass.
/// These textures are useful for various screen-space effects and reducing overdraw in the main pass.
///
/// The textures are automatically added to the default mesh view bindings. You can also get the raw textures
/// by querying the [`ViewPrepassTextures`] component on the camera with the [`PrepassSettings`].
///
/// When using the default mesh view bindings you should be able to use `prepass_depth()`,
/// `prepass_normal()`, and `prepass_velocity()` to load the related textures.
/// These functions are defined in `bevy_pbr::utils`. See the `shader_prepass` example that shows how to use it.
#[derive(Clone, Component)]
pub struct PrepassSettings {
    /// If enabled then depth values will be copied to a separate texture available to the main pass.
    /// This will help reduce overdraw in the main pass.
    pub depth_settings: PrepassDepthSettings,
    /// If true then vertex world normals will be copied to a separate texture available to the main pass.
    pub normal_enabled: bool,
    /// If true then velocity values will be copied to a separate texture available to the main pass.
    pub velocity_enabled: bool,
}

#[derive(Clone, Component)]
pub enum PrepassDepthSettings {
    Disabled,
    Enabled { keep_1_frame_history: bool },
}

impl PrepassSettings {
    pub fn all() -> Self {
        Self {
            depth_settings: {
                PrepassDepthSettings::Enabled {
                    keep_1_frame_history: true,
                }
            },
            normal_enabled: true,
            velocity_enabled: true,
        }
    }

    pub fn depth_enabled(&self) -> bool {
        match self.depth_settings {
            PrepassDepthSettings::Disabled => false,
            PrepassDepthSettings::Enabled { .. } => true,
        }
    }
}

impl Default for PrepassSettings {
    fn default() -> Self {
        Self {
            depth_settings: {
                PrepassDepthSettings::Enabled {
                    keep_1_frame_history: false,
                }
            },
            normal_enabled: false,
            velocity_enabled: false,
        }
    }
}

/// Textures that are written to by the prepass.
///
/// The texture only exists if the relevant option on [`PrepassSettings`] is `true`.
#[derive(Component)]
pub struct ViewPrepassTextures {
    /// The depth texture generated by the prepass.
    /// Exists only if `depth_enabled` on [`PrepassSettings`] is true.
    pub depth: Option<CachedTexture>,
    pub previous_depth: Option<CachedTexture>,
    /// The normals texture generated by the prepass.
    /// Exists only if `normal_enabled` on [`PrepassSettings`] is true.
    pub normal: Option<CachedTexture>,
    /// The velocities texture generated by the prepass.
    /// Exists only if `velocity_enabled` on [`PrepassSettings`] is true.
    pub velocity: Option<CachedTexture>,
    /// The size of the textures.
    pub size: Extent3d,
}

/// Opaque phase of the 3d prepass.
///
/// Sorted on the distance.
///
/// Used to render all 3d meshes with materials that have no transparency.
pub struct Opaque3dPrepass {
    pub distance: f32,
    pub entity: Entity,
    pub pipeline_id: CachedRenderPipelineId,
    pub draw_function: DrawFunctionId,
}

impl PhaseItem for Opaque3dPrepass {
    type SortKey = FloatOrd;

    #[inline]
    fn sort_key(&self) -> Self::SortKey {
        FloatOrd(self.distance)
    }

    #[inline]
    fn draw_function(&self) -> DrawFunctionId {
        self.draw_function
    }

    #[inline]
    fn sort(items: &mut [Self]) {
        radsort::sort_by_key(items, |item| item.distance);
    }
}

impl EntityPhaseItem for Opaque3dPrepass {
    fn entity(&self) -> Entity {
        self.entity
    }
}

impl CachedRenderPipelinePhaseItem for Opaque3dPrepass {
    #[inline]
    fn cached_pipeline(&self) -> CachedRenderPipelineId {
        self.pipeline_id
    }
}

/// Alpha mask phase of the 3d prepaas.
///
/// Sorted on the distance.
///
/// Used to render all meshes with a material with an alpha mask.
pub struct AlphaMask3dPrepass {
    pub distance: f32,
    pub entity: Entity,
    pub pipeline_id: CachedRenderPipelineId,
    pub draw_function: DrawFunctionId,
}

impl PhaseItem for AlphaMask3dPrepass {
    type SortKey = FloatOrd;

    #[inline]
    fn sort_key(&self) -> Self::SortKey {
        FloatOrd(self.distance)
    }

    #[inline]
    fn draw_function(&self) -> DrawFunctionId {
        self.draw_function
    }

    #[inline]
    fn sort(items: &mut [Self]) {
        radsort::sort_by_key(items, |item| item.distance);
    }
}

impl EntityPhaseItem for AlphaMask3dPrepass {
    fn entity(&self) -> Entity {
        self.entity
    }
}

impl CachedRenderPipelinePhaseItem for AlphaMask3dPrepass {
    #[inline]
    fn cached_pipeline(&self) -> CachedRenderPipelineId {
        self.pipeline_id
    }
}
